// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_json = require("bs-platform/lib/js/js_json.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Json_decode = require("bs-json/src/Json_decode.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Types$LonaCompilerCore = require("./types.bs.js");
var ParameterKey$LonaCompilerCore = require("./parameterKey.bs.js");
var ParameterMap$LonaCompilerCore = require("../containers/parameterMap.bs.js");

var UnknownParameter = Caml_exceptions.create("Decode-LonaCompilerCore.UnknownParameter");

var UnknownType = Caml_exceptions.create("Decode-LonaCompilerCore.UnknownType");

function parameterType(key) {
  if (typeof key === "number") {
    switch (key) {
      case 3 : 
          return Types$LonaCompilerCore.textStyleType;
      case 5 : 
          return Types$LonaCompilerCore.urlType;
      case 1 : 
      case 2 : 
      case 6 : 
      case 7 : 
      case 10 : 
      case 11 : 
          return Types$LonaCompilerCore.stringType;
      case 8 : 
      case 22 : 
          return Types$LonaCompilerCore.colorType;
      case 4 : 
      case 9 : 
      case 12 : 
      case 13 : 
      case 14 : 
      case 15 : 
      case 16 : 
      case 17 : 
      case 18 : 
      case 19 : 
      case 20 : 
      case 21 : 
      case 23 : 
      case 24 : 
          return Types$LonaCompilerCore.numberType;
      case 0 : 
      case 25 : 
      case 26 : 
          return Types$LonaCompilerCore.booleanType;
      case 27 : 
          return Types$LonaCompilerCore.handlerType;
      
    }
  } else {
    var name = key[0];
    console.log("Unknown built-in parameter when deserializing:", name);
    throw [
          UnknownParameter,
          name
        ];
  }
}

function lonaType(json) {
  var referenceType = function (json) {
    return /* Reference */Block.__(0, [Json_decode.string(json)]);
  };
  var otherType = function (json) {
    var name = Json_decode.field("name", Json_decode.string, json);
    switch (name) {
      case "Function" : 
          var json$1 = json;
          var argumentType = function (json) {
            return {
                    label: Json_decode.field("label", Json_decode.string, json),
                    type: Json_decode.field("type", lonaType, json)
                  };
          };
          var match = Json_decode.optional((function (param) {
                  return Json_decode.field("arguments", (function (param) {
                                return Json_decode.list(argumentType, param);
                              }), param);
                }), json$1);
          var $$arguments = match ? match[0] : /* [] */0;
          var match$1 = Json_decode.optional((function (param) {
                  return Json_decode.field("arguments", (function (param) {
                                return Json_decode.field("returnType", lonaType, param);
                              }), param);
                }), json$1);
          var returnType = match$1 ? match$1[0] : Types$LonaCompilerCore.undefinedType;
          return /* Function */Block.__(2, [
                    $$arguments,
                    returnType
                  ]);
      case "Named" : 
          var json$2 = json;
          var named = Json_decode.field("alias", Json_decode.string, json$2);
          var ltype = Json_decode.field("of", lonaType, json$2);
          return /* Named */Block.__(1, [
                    named,
                    ltype
                  ]);
      default:
        throw [
              UnknownType,
              name
            ];
    }
  };
  return Json_decode.oneOf(/* :: */[
              referenceType,
              /* :: */[
                otherType,
                /* [] */0
              ]
            ], json);
}

var Types = /* module */[/* lonaType */lonaType];

function parameterKey(json) {
  return ParameterKey$LonaCompilerCore.fromString(Json_decode.string(json));
}

function parameter(json) {
  return /* record */[
          /* name */Json_decode.field("name", parameterKey, json),
          /* ltype */Json_decode.field("type", lonaType, json),
          /* defaultValue */Json_decode.optional((function (param) {
                  return Json_decode.field("defaultValue", (function (x) {
                                return x;
                              }), param);
                }), json)
        ];
}

var Parameters = /* module */[
  /* parameterKey */parameterKey,
  /* parameter */parameter
];

function layerType(json) {
  var value = Json_decode.string(json);
  switch (value) {
    case "Lona:Animation" : 
        return /* Animation */3;
    case "Lona:Children" : 
        return /* Children */4;
    case "Lona:Image" : 
        return /* Image */2;
    case "Lona:Text" : 
        return /* Text */1;
    case "Lona:View" : 
        return /* View */0;
    default:
      return /* Component */[value];
  }
}

function layer(getComponent, json) {
  var typeName = Json_decode.field("type", layerType, json);
  var parameterDictionary = function (json) {
    return Curry._2(ParameterMap$LonaCompilerCore.mapi, (function (key, value) {
                  if (typeof typeName === "number") {
                    return /* record */[
                            /* ltype */parameterType(key),
                            /* data */value
                          ];
                  } else {
                    var param = List.find((function (param) {
                            return Caml_obj.caml_equal(param[/* name */0], key);
                          }), Json_decode.field("params", (function (param) {
                                return Json_decode.list(parameter, param);
                              }), Curry._1(getComponent, typeName[0])));
                    var exit = 0;
                    var val;
                    try {
                      val = param;
                      exit = 1;
                    }
                    catch (exn){
                      console.log("Unknown built-in parameter when deserializing:", key);
                      throw [
                            UnknownParameter,
                            ParameterKey$LonaCompilerCore.toString(key)
                          ];
                    }
                    if (exit === 1) {
                      return /* record */[
                              /* ltype */param[/* ltype */1],
                              /* data */value
                            ];
                    }
                    
                  }
                }), ParameterMap$LonaCompilerCore.fromJsDict(Js_option.getExn(Js_json.decodeObject(json))));
  };
  var name = Json_decode.field("id", Json_decode.string, json);
  var tmp;
  var exit = 0;
  var val;
  try {
    val = Json_decode.optional((function (param) {
            return Json_decode.field("children", (function (param) {
                          return Json_decode.list((function (param) {
                                        return layer(getComponent, param);
                                      }), param);
                        }), param);
          }), json);
    exit = 1;
  }
  catch (e){
    console.log("Failed to decode children of", Types$LonaCompilerCore.layerTypeToString(typeName), name);
    throw e;
  }
  if (exit === 1) {
    tmp = val ? val[0] : /* [] */0;
  }
  return /* record */[
          /* typeName */typeName,
          /* name */name,
          /* parameters */Json_decode.field("params", parameterDictionary, json),
          /* children */tmp
        ];
}

var Layer = /* module */[
  /* layerType */layerType,
  /* layer */layer
];

var UnknownExprType = Caml_exceptions.create("Decode-LonaCompilerCore.UnknownExprType");

function decodeExpr(json) {
  var decodePlaceholder = function () {
    return /* PlaceholderExpression */0;
  };
  var decodeIdentifier = function (json) {
    return /* IdentifierExpression */Block.__(5, [Json_decode.string(json)]);
  };
  var decodeMemberExpression = function (json) {
    return /* MemberExpression */Block.__(4, [Json_decode.list(decodeExpr, json)]);
  };
  var decodeTypedExpr = function (json) {
    var exprType = Json_decode.field("type", Json_decode.string, json);
    switch (exprType) {
      case "AssignExpr" : 
          return /* AssignmentExpression */Block.__(0, [{
                      assignee: Json_decode.field("assignee", decodeExpr, json),
                      content: Json_decode.field("content", decodeExpr, json)
                    }]);
      case "BinExpr" : 
          return /* BinaryExpression */Block.__(3, [{
                      left: Json_decode.field("left", decodeExpr, json),
                      op: Json_decode.field("op", decodeExpr, json),
                      right: Json_decode.field("right", decodeExpr, json)
                    }]);
      case "IfExpr" : 
          return /* IfExpression */Block.__(1, [{
                      condition: Json_decode.field("condition", decodeExpr, json),
                      body: Json_decode.field("body", (function (param) {
                              return Json_decode.list(decodeExpr, param);
                            }), json)
                    }]);
      case "LitExpr" : 
          return /* LiteralExpression */Block.__(6, [/* record */[
                      /* ltype */Json_decode.at(/* :: */[
                              "value",
                              /* :: */[
                                "type",
                                /* [] */0
                              ]
                            ], lonaType)(json),
                      /* data */Json_decode.at(/* :: */[
                              "value",
                              /* :: */[
                                "data",
                                /* [] */0
                              ]
                            ], (function (json) {
                                return json;
                              }))(json)
                    ]]);
      case "VarDeclExpr" : 
          return /* VariableDeclarationExpression */Block.__(2, [{
                      content: Json_decode.field("content", decodeExpr, json),
                      identifier: Json_decode.field("id", decodeExpr, json)
                    }]);
      default:
        throw [
              UnknownExprType,
              exprType
            ];
    }
  };
  return Json_decode.oneOf(/* :: */[
              decodeTypedExpr,
              /* :: */[
                decodeIdentifier,
                /* :: */[
                  decodeMemberExpression,
                  /* :: */[
                    decodePlaceholder,
                    /* [] */0
                  ]
                ]
              ]
            ], json);
}

var UnknownLogicValue = Caml_exceptions.create("Decode-LonaCompilerCore.UnknownLogicValue");

function logicNode(json) {
  var cmp = function (str) {
    switch (str) {
      case "!=" : 
          return /* Neq */1;
      case "<" : 
          return /* Lt */4;
      case "<=" : 
          return /* Lte */5;
      case "==" : 
          return /* Eq */0;
      case ">" : 
          return /* Gt */2;
      case ">=" : 
          return /* Gte */3;
      default:
        return /* Unknown */6;
    }
  };
  var identifierFromExpr = function (expr) {
    if (typeof expr === "number") {
      throw [
            UnknownExprType,
            "Expected identifier"
          ];
    } else if (expr.tag === 5) {
      return expr[0];
    } else {
      throw [
            UnknownExprType,
            "Expected identifier"
          ];
    }
  };
  var logicValueFromExpr = function (expr) {
    if (typeof expr === "number") {
      throw [
            UnknownExprType,
            "Failed to convert logic value"
          ];
    } else {
      switch (expr.tag | 0) {
        case 4 : 
            var path = List.map(identifierFromExpr, expr[0]);
            return /* Identifier */Block.__(0, [
                      /* Reference */Block.__(0, ["???"]),
                      path
                    ]);
        case 6 : 
            return /* Literal */Block.__(1, [expr[0]]);
        default:
          throw [
                UnknownExprType,
                "Failed to convert logic value"
              ];
      }
    }
  };
  var fromExpr = function (expr) {
    if (typeof expr === "number") {
      return /* None */0;
    } else {
      switch (expr.tag | 0) {
        case 0 : 
            var o = expr[0];
            var content = logicValueFromExpr(o.content);
            var assignee = logicValueFromExpr(o.assignee);
            return /* Assign */Block.__(2, [
                      content,
                      assignee
                    ]);
        case 1 : 
            var o$1 = expr[0];
            var body = List.map(fromExpr, o$1.body);
            var match = o$1.condition;
            if (typeof match === "number") {
              throw [
                    UnknownExprType,
                    "Unknown PlaceholderExpression"
                  ];
            } else {
              switch (match.tag | 0) {
                case 0 : 
                    throw [
                          UnknownExprType,
                          "Unknown AssignmentExpression"
                        ];
                case 1 : 
                    throw [
                          UnknownExprType,
                          "Unknown IfExpression"
                        ];
                case 2 : 
                    var decl = match[0];
                    var id = identifierFromExpr(decl.identifier);
                    var content$1 = logicValueFromExpr(decl.content);
                    return /* IfExists */Block.__(1, [
                              content$1,
                              /* Block */Block.__(6, [/* :: */[
                                    /* LetEqual */Block.__(5, [
                                        /* Identifier */Block.__(0, [
                                            Types$LonaCompilerCore.undefinedType,
                                            /* :: */[
                                              id,
                                              /* [] */0
                                            ]
                                          ]),
                                        content$1
                                      ]),
                                    body
                                  ]])
                            ]);
                case 3 : 
                    var bin = match[0];
                    var left = logicValueFromExpr(bin.left);
                    var right = logicValueFromExpr(bin.right);
                    var op = cmp(identifierFromExpr(bin.op));
                    return /* If */Block.__(0, [
                              left,
                              op,
                              right,
                              /* Block */Block.__(6, [body])
                            ]);
                case 4 : 
                    throw [
                          UnknownExprType,
                          "Unknown MemberExpression"
                        ];
                case 5 : 
                    throw [
                          UnknownExprType,
                          "Unknown IdentifierExpression"
                        ];
                case 6 : 
                    throw [
                          UnknownExprType,
                          "Unknown LiteralExpression"
                        ];
                
              }
            }
        default:
          return /* None */0;
      }
    }
  };
  return fromExpr(decodeExpr(json));
}

function parameters(json) {
  return Json_decode.field("params", (function (param) {
                return Json_decode.list(parameter, param);
              }), json);
}

function rootLayer(getComponent, json) {
  return Json_decode.field("root", (function (param) {
                return layer(getComponent, param);
              }), json);
}

function logic(json) {
  return /* Block */Block.__(6, [Json_decode.field("logic", (function (param) {
                    return Json_decode.list(logicNode, param);
                  }), json)]);
}

var Component = /* module */[
  /* parameters */parameters,
  /* rootLayer */rootLayer,
  /* logic */logic
];

var reference = Types$LonaCompilerCore.reference;

var named = Types$LonaCompilerCore.named;

var $$function = Types$LonaCompilerCore.$$function;

var undefinedType = Types$LonaCompilerCore.undefinedType;

var referenceFromJs = Types$LonaCompilerCore.referenceFromJs;

var booleanType = Types$LonaCompilerCore.booleanType;

var numberType = Types$LonaCompilerCore.numberType;

var stringType = Types$LonaCompilerCore.stringType;

var colorType = Types$LonaCompilerCore.colorType;

var textStyleType = Types$LonaCompilerCore.textStyleType;

var urlType = Types$LonaCompilerCore.urlType;

var handlerType = Types$LonaCompilerCore.handlerType;

var parameterToJs = Types$LonaCompilerCore.parameterToJs;

var parameterFromJs = Types$LonaCompilerCore.parameterFromJs;

var layerTypeToString = Types$LonaCompilerCore.layerTypeToString;

var decodeParameters = parameters;

var decodeRootLayer = rootLayer;

var decodeLogic = logic;

exports.reference = reference;
exports.named = named;
exports.$$function = $$function;
exports.undefinedType = undefinedType;
exports.referenceFromJs = referenceFromJs;
exports.booleanType = booleanType;
exports.numberType = numberType;
exports.stringType = stringType;
exports.colorType = colorType;
exports.textStyleType = textStyleType;
exports.urlType = urlType;
exports.handlerType = handlerType;
exports.parameterToJs = parameterToJs;
exports.parameterFromJs = parameterFromJs;
exports.layerTypeToString = layerTypeToString;
exports.UnknownParameter = UnknownParameter;
exports.UnknownType = UnknownType;
exports.parameterType = parameterType;
exports.Types = Types;
exports.Parameters = Parameters;
exports.Layer = Layer;
exports.UnknownExprType = UnknownExprType;
exports.decodeExpr = decodeExpr;
exports.UnknownLogicValue = UnknownLogicValue;
exports.logicNode = logicNode;
exports.Component = Component;
exports.decodeParameters = decodeParameters;
exports.decodeRootLayer = decodeRootLayer;
exports.decodeLogic = decodeLogic;
/* ParameterMap-LonaCompilerCore Not a pure module */
